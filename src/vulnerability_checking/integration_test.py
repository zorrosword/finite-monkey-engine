#!/usr/bin/env python3
"""
VulnerabilityChecker é›†æˆæµ‹è¯•

è¿™ä¸ªæµ‹è¯•æ¨¡æ‹ŸçœŸå®çš„æ¼æ´æ£€æŸ¥æµç¨‹ï¼ŒåŒ…æ‹¬ï¼š
1. åˆ›å»ºæ¨¡æ‹Ÿçš„ä»»åŠ¡æ•°æ®
2. æµ‹è¯•å®Œæ•´çš„æ¼æ´æ£€æŸ¥æµç¨‹
3. éªŒè¯å„ä¸ªå¤„ç†å™¨çš„åä½œ
4. æ£€æŸ¥ç»“æœæ ¼å¼å’Œå†…å®¹
"""

import sys
import os
from unittest.mock import Mock, MagicMock, patch

# æ·»åŠ srcç›®å½•åˆ°Pythonè·¯å¾„
src_path = os.path.join(os.path.dirname(__file__), '..')
sys.path.insert(0, src_path)
print(f"ğŸ”§ å·²æ·»åŠ è·¯å¾„åˆ°sys.path: {src_path}")


def create_mock_task(task_id, score="0", if_business_flow_scan="0"):
    """åˆ›å»ºæ¨¡æ‹Ÿä»»åŠ¡å¯¹è±¡"""
    task = Mock()
    task.id = task_id
    task.score = score
    task.if_business_flow_scan = if_business_flow_scan
    task.content = f"function test{task_id}() {{ /* test function {task_id} */ }}"
    task.business_flow_code = f"// Business flow code for task {task_id}"
    task.business_flow_context = ""
    
    # æ¨¡æ‹Ÿç»“æœè·å–æ–¹æ³•
    task.get_result.return_value = f"Potential vulnerability in function test{task_id}"
    task.get_result_CN.return_value = None
    task.get_category.return_value = None
    
    return task


def create_mock_task_manager():
    """åˆ›å»ºæ¨¡æ‹Ÿä»»åŠ¡ç®¡ç†å™¨"""
    task_manager = Mock()
    
    # åˆ›å»ºä¸€äº›æµ‹è¯•ä»»åŠ¡
    tasks = [
        create_mock_task(1, score="0", if_business_flow_scan="0"),
        create_mock_task(2, score="1", if_business_flow_scan="0"),  # å·²å¤„ç†
        create_mock_task(3, score="0", if_business_flow_scan="1"),  # ä¸šåŠ¡æµ
    ]
    
    task_manager.get_task_list.return_value = tasks
    task_manager.update_business_flow_context = Mock()
    task_manager.update_score = Mock()
    task_manager.update_result = Mock()
    task_manager.update_category = Mock()
    
    return task_manager, tasks


def create_mock_project_audit():
    """åˆ›å»ºæ¨¡æ‹Ÿé¡¹ç›®å®¡è®¡å¯¹è±¡"""
    project_audit = Mock()
    
    # æ¨¡æ‹Ÿcall_treesæ•°æ®
    project_audit.call_trees = [
        {
            'function': 'test1',
            'upstream_tree': {
                'function_data': {
                    'name': 'test1',
                    'content': 'function test1() { /* upstream function */ }'
                },
                'children': []
            },
            'downstream_tree': {
                'function_data': {
                    'name': 'test1',
                    'content': 'function test1() { /* downstream function */ }'
                },
                'children': []
            },
            'state_variables': 'uint256 public balance;'
        }
    ]
    
    # æ¨¡æ‹Ÿfunctions_to_checkæ•°æ®
    project_audit.functions_to_check = [
        {
            'name': 'Contract.test1',
            'content': 'function test1() { /* test function 1 */ }'
        },
        {
            'name': 'Contract.test3',
            'content': 'function test3() { /* test function 3 */ }'
        }
    ]
    
    return project_audit


def test_context_update_flow():
    """æµ‹è¯•ä¸Šä¸‹æ–‡æ›´æ–°æµç¨‹"""
    print("\nğŸ” æµ‹è¯•ä¸Šä¸‹æ–‡æ›´æ–°æµç¨‹...")
    
    try:
        from vulnerability_checking import VulnerabilityChecker
        
        # åˆ›å»ºæ¨¡æ‹Ÿå¯¹è±¡
        mock_project_audit = create_mock_project_audit()
        mock_lancedb = Mock()
        
        # æ¨¡æ‹Ÿå‘é‡æœç´¢ç»“æœ
        mock_table = Mock()
        mock_lancedb.open_table.return_value = mock_table
        mock_table.search.return_value.limit.return_value.to_list.return_value = [
            {'name': 'Contract.test1', 'content': 'function test1() { /* related function */ }'}
        ]
        
        task_manager, tasks = create_mock_task_manager()
        
        # æ¨¡æ‹Ÿembedding APIè°ƒç”¨
        with patch('vulnerability_checking.utils.context_manager.common_get_embedding') as mock_embedding:
            mock_embedding.return_value = [0.1, 0.2, 0.3]  # æ¨¡æ‹Ÿembeddingå‘é‡
            
            # åˆ›å»ºVulnerabilityChecker
            checker = VulnerabilityChecker(mock_project_audit, mock_lancedb, "test_table")
            
            # è¿è¡Œä¸Šä¸‹æ–‡æ›´æ–°
            checker.context_update_processor.update_business_flow_context(task_manager)
            
            # éªŒè¯è°ƒç”¨
            assert task_manager.update_business_flow_context.call_count >= 0  # å¯èƒ½æ²¡æœ‰éœ€è¦æ›´æ–°çš„ä»»åŠ¡
            print("âœ… ä¸Šä¸‹æ–‡æ›´æ–°æµç¨‹æµ‹è¯•é€šè¿‡")
            
            return True
    except Exception as e:
        print(f"âŒ ä¸Šä¸‹æ–‡æ›´æ–°æµç¨‹æµ‹è¯•å¤±è´¥: {e}")
        return False


def test_complete_vulnerability_check_flow():
    """æµ‹è¯•å®Œæ•´çš„æ¼æ´æ£€æŸ¥æµç¨‹"""
    print("\nğŸ” æµ‹è¯•å®Œæ•´çš„æ¼æ´æ£€æŸ¥æµç¨‹...")
    
    try:
        from vulnerability_checking import VulnerabilityChecker
        
        # åˆ›å»ºæ¨¡æ‹Ÿå¯¹è±¡
        mock_project_audit = create_mock_project_audit()
        mock_lancedb = Mock()
        
        # æ¨¡æ‹Ÿå‘é‡æœç´¢ç»“æœ
        mock_table = Mock()
        mock_lancedb.open_table.return_value = mock_table
        mock_table.search.return_value.limit.return_value.to_list.return_value = [
            {'name': 'Contract.test1', 'content': 'function test1() { /* related function */ }'}
        ]
        
        task_manager, tasks = create_mock_task_manager()
        
        # æ¨¡æ‹Ÿembedding APIè°ƒç”¨å’Œå…¶ä»–APIè°ƒç”¨
        with patch('vulnerability_checking.utils.context_manager.common_get_embedding') as mock_embedding:
            with patch('vulnerability_checking.processors.analysis_processor.common_ask_confirmation') as mock_ask:
                with patch('vulnerability_checking.utils.check_utils.common_ask_for_json') as mock_ask_json:
                    with patch('vulnerability_checking.utils.check_utils.common_ask_confirmation') as mock_ask_confirm:
                        # æ¨¡æ‹Ÿembeddingå‘é‡
                        mock_embedding.return_value = [0.1, 0.2, 0.3]
                        
                        # æ¨¡æ‹ŸAPIå“åº”
                        mock_ask.return_value = "Initial analysis shows no vulnerability found."
                        mock_ask_json.return_value = '{"result": "no vulnerability"}'
                        mock_ask_confirm.return_value = "Confirmation: no vulnerability detected."
                        
                        # åˆ›å»ºVulnerabilityChecker
                        checker = VulnerabilityChecker(mock_project_audit, mock_lancedb, "test_table")
                        
                        # è¿è¡Œå®Œæ•´çš„æ£€æŸ¥æµç¨‹
                        result = checker.check_function_vul(task_manager)
                        
                        print(f"âœ… å®Œæ•´æ£€æŸ¥æµç¨‹æµ‹è¯•é€šè¿‡ï¼Œè¿”å›ç»“æœ: {type(result)}")
                        return True
    except Exception as e:
        print(f"âŒ å®Œæ•´æ£€æŸ¥æµç¨‹æµ‹è¯•å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_processor_isolation():
    """æµ‹è¯•å¤„ç†å™¨éš”ç¦»æ€§"""
    print("\nğŸ” æµ‹è¯•å¤„ç†å™¨éš”ç¦»æ€§...")
    
    try:
        from vulnerability_checking.processors import (
            ContextUpdateProcessor,
            ConfirmationProcessor,
            AnalysisProcessor
        )
        from vulnerability_checking.utils import ContextManager
        
        # åˆ›å»ºç‹¬ç«‹çš„å¤„ç†å™¨å®ä¾‹
        mock_project_audit = create_mock_project_audit()
        mock_lancedb = Mock()
        
        context_manager = ContextManager(mock_project_audit, mock_lancedb, "test_table")
        context_processor = ContextUpdateProcessor(context_manager)
        analysis_processor = AnalysisProcessor(context_manager)
        confirmation_processor = ConfirmationProcessor(analysis_processor)
        
        # éªŒè¯å¤„ç†å™¨å¯ä»¥ç‹¬ç«‹ä½¿ç”¨
        assert context_processor.context_manager is not None
        assert analysis_processor.context_manager is not None
        assert confirmation_processor.analysis_processor is not None
        
        print("âœ… å¤„ç†å™¨éš”ç¦»æ€§æµ‹è¯•é€šè¿‡")
        return True
    except Exception as e:
        print(f"âŒ å¤„ç†å™¨éš”ç¦»æ€§æµ‹è¯•å¤±è´¥: {e}")
        return False


def test_api_backward_compatibility():
    """æµ‹è¯•APIå‘åå…¼å®¹æ€§"""
    print("\nğŸ” æµ‹è¯•APIå‘åå…¼å®¹æ€§...")
    
    try:
        from vulnerability_checking import VulnerabilityChecker
        
        # æµ‹è¯•åŸæœ‰APIæ¥å£
        mock_project_audit = create_mock_project_audit()
        mock_lancedb = Mock()
        task_manager, _ = create_mock_task_manager()
        
        # åˆ›å»ºcheckerå¹¶æµ‹è¯•ä¸»è¦API
        checker = VulnerabilityChecker(mock_project_audit, mock_lancedb, "test_table")
        
        # éªŒè¯APIç­¾å
        import inspect
        api_method = checker.check_function_vul
        sig = inspect.signature(api_method)
        
        # éªŒè¯å‚æ•°
        params = list(sig.parameters.keys())
        assert 'task_manager' in params or len(params) == 1
        
        print("âœ… APIå‘åå…¼å®¹æ€§æµ‹è¯•é€šè¿‡")
        return True
    except Exception as e:
        print(f"âŒ APIå‘åå…¼å®¹æ€§æµ‹è¯•å¤±è´¥: {e}")
        return False


def test_error_handling():
    """æµ‹è¯•é”™è¯¯å¤„ç†"""
    print("\nğŸ” æµ‹è¯•é”™è¯¯å¤„ç†...")
    
    try:
        from vulnerability_checking import VulnerabilityChecker
        
        # æµ‹è¯•å„ç§å¼‚å¸¸æƒ…å†µ
        mock_project_audit = Mock()
        mock_project_audit.call_trees = []
        mock_project_audit.functions_to_check = []
        
        mock_lancedb = Mock()
        mock_lancedb.open_table.side_effect = Exception("Database connection error")
        
        # å°è¯•åˆ›å»ºcheckerï¼ˆåº”è¯¥èƒ½å¤„ç†æ•°æ®åº“é”™è¯¯ï¼‰
        try:
            checker = VulnerabilityChecker(mock_project_audit, mock_lancedb, "test_table")
            print("   - VulnerabilityChecker åˆ›å»ºæˆåŠŸï¼ˆå³ä½¿æ•°æ®åº“æœ‰é—®é¢˜ï¼‰")
        except Exception:
            print("   - VulnerabilityChecker åˆ›å»ºå¤±è´¥ï¼ˆé¢„æœŸè¡Œä¸ºï¼‰")
        
        print("âœ… é”™è¯¯å¤„ç†æµ‹è¯•é€šè¿‡")
        return True
    except Exception as e:
        print(f"âŒ é”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥: {e}")
        return False


def test_new_confirmation_logic():
    """æµ‹è¯•æ–°çš„æŒ‰è½®æ¬¡ç¡®è®¤é€»è¾‘"""
    print("\nğŸ” æµ‹è¯•æ–°çš„æŒ‰è½®æ¬¡ç¡®è®¤é€»è¾‘...")
    
    try:
        from vulnerability_checking.utils import CheckUtils
        
        # æµ‹è¯•åœºæ™¯1: ç¬¬1è½®æœ‰3ä¸ªyesï¼Œç¬¬2è½®æœ‰noï¼Œåº”è¯¥è¾“å‡ºyes
        round_results_1 = [
            ["yes vulnerability", "yes confirmed", "yes high risk"],  # ç¬¬1è½®ï¼š3ä¸ªyes
            ["no vulnerability", "no issues"]  # ç¬¬2è½®ï¼š2ä¸ªno
        ]
        
        analysis_collection_1 = []
        result_1, _ = CheckUtils.collect_analysis_results_by_rounds(analysis_collection_1, round_results_1)
        assert result_1 == "yes", f"æµ‹è¯•åœºæ™¯1å¤±è´¥ï¼šæœŸæœ›yesï¼Œå®é™…{result_1}"
        print("   âœ… åœºæ™¯1é€šè¿‡ï¼šç¬¬1è½®3ä¸ªyesè¦†ç›–ç¬¬2è½®çš„no")
        
        # æµ‹è¯•åœºæ™¯2: ç¬¬1è½®æœ‰2ä¸ªyesæ— noï¼Œç¬¬2è½®æœ‰noï¼Œåº”è¯¥è¾“å‡ºyes  
        round_results_2 = [
            ["yes vulnerability", "yes confirmed"],  # ç¬¬1è½®ï¼š2ä¸ªyesï¼Œæ— no
            ["no vulnerability", "no issues", "no risk"]  # ç¬¬2è½®ï¼š3ä¸ªno
        ]
        
        analysis_collection_2 = []
        result_2, _ = CheckUtils.collect_analysis_results_by_rounds(analysis_collection_2, round_results_2)
        assert result_2 == "yes", f"æµ‹è¯•åœºæ™¯2å¤±è´¥ï¼šæœŸæœ›yesï¼Œå®é™…{result_2}"
        print("   âœ… åœºæ™¯2é€šè¿‡ï¼šç¬¬1è½®2ä¸ªyesæ— noè¦†ç›–ç¬¬2è½®çš„no")
        
        # æµ‹è¯•åœºæ™¯3: ç¬¬1è½®æœ‰2ä¸ªyeså’Œ1ä¸ªnoï¼Œç¬¬2è½®ä¹Ÿæœ‰noï¼Œåº”è¯¥æŒ‰æ€»ä½“é€»è¾‘
        round_results_3 = [
            ["yes vulnerability", "yes confirmed", "no vulnerability"],  # ç¬¬1è½®ï¼š2ä¸ªyesï¼Œ1ä¸ªno(åŒ…å«vulnerability)
            ["no vulnerability", "no vulnerability found"]  # ç¬¬2è½®ï¼š2ä¸ªno(éƒ½åŒ…å«vulnerability)
        ]
        
        analysis_collection_3 = []
        result_3, _ = CheckUtils.collect_analysis_results_by_rounds(analysis_collection_3, round_results_3)
        # è¿™ç§æƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨æ€»ä½“é€»è¾‘ï¼š2ä¸ªyes vs 3ä¸ªno(éƒ½åŒ…å«vulnerability)ï¼Œåº”è¯¥æ˜¯no
        expected_3 = "no"  # æ€»ä½“3ä¸ªno > 2ä¸ªyes
        assert result_3 == expected_3, f"æµ‹è¯•åœºæ™¯3å¤±è´¥ï¼šæœŸæœ›{expected_3}ï¼Œå®é™…{result_3}"
        print("   âœ… åœºæ™¯3é€šè¿‡ï¼šæ— å¼ºç¡®è®¤è½®æ¬¡ï¼Œä½¿ç”¨æ€»ä½“é€»è¾‘")
        
        # æµ‹è¯•åœºæ™¯4: ç¬¬2è½®æ»¡è¶³å¼ºç¡®è®¤æ¡ä»¶
        round_results_4 = [
            ["no vulnerability", "no issues"],  # ç¬¬1è½®ï¼š2ä¸ªno
            ["yes vulnerability", "yes confirmed", "yes high risk"]  # ç¬¬2è½®ï¼š3ä¸ªyes
        ]
        
        analysis_collection_4 = []
        result_4, _ = CheckUtils.collect_analysis_results_by_rounds(analysis_collection_4, round_results_4)
        assert result_4 == "yes", f"æµ‹è¯•åœºæ™¯4å¤±è´¥ï¼šæœŸæœ›yesï¼Œå®é™…{result_4}"
        print("   âœ… åœºæ™¯4é€šè¿‡ï¼šç¬¬2è½®3ä¸ªyesè¦†ç›–ç¬¬1è½®çš„no")
        
        print("âœ… æ–°çš„æŒ‰è½®æ¬¡ç¡®è®¤é€»è¾‘æµ‹è¯•é€šè¿‡")
        return True
    except Exception as e:
        print(f"âŒ æ–°çš„æŒ‰è½®æ¬¡ç¡®è®¤é€»è¾‘æµ‹è¯•å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        return False


def run_integration_tests():
    """è¿è¡Œæ‰€æœ‰é›†æˆæµ‹è¯•"""
    print("ğŸš€ å¼€å§‹VulnerabilityCheckeré›†æˆæµ‹è¯•")
    print("=" * 60)
    
    tests = [
        ("ä¸Šä¸‹æ–‡æ›´æ–°æµç¨‹æµ‹è¯•", test_context_update_flow),
        ("å®Œæ•´æ¼æ´æ£€æŸ¥æµç¨‹æµ‹è¯•", test_complete_vulnerability_check_flow),
        ("å¤„ç†å™¨éš”ç¦»æ€§æµ‹è¯•", test_processor_isolation),
        ("APIå‘åå…¼å®¹æ€§æµ‹è¯•", test_api_backward_compatibility),
        ("é”™è¯¯å¤„ç†æµ‹è¯•", test_error_handling),
        ("æ–°çš„æŒ‰è½®æ¬¡ç¡®è®¤é€»è¾‘æµ‹è¯•", test_new_confirmation_logic),
    ]
    
    passed = 0
    total = len(tests)
    
    for test_name, test_func in tests:
        try:
            if test_func():
                passed += 1
            else:
                print(f"âŒ {test_name} å¤±è´¥")
        except Exception as e:
            print(f"âŒ {test_name} å¼‚å¸¸: {e}")
    
    print("\n" + "=" * 60)
    print(f"ğŸ“Š é›†æˆæµ‹è¯•ç»“æœ: {passed}/{total} é€šè¿‡")
    
    if passed == total:
        print("ğŸ‰ æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡ï¼é‡æ„çš„VulnerabilityCheckeråŠŸèƒ½å®Œå…¨æ­£å¸¸ï¼")
        return True
    else:
        print("âš ï¸ éƒ¨åˆ†é›†æˆæµ‹è¯•å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥")
        return False


if __name__ == "__main__":
    success = run_integration_tests()
    sys.exit(0 if success else 1) 